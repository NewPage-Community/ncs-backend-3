// Code generated by MockGen. DO NOT EDIT.
// Source: app/game/store/api/grpc/v1/store_grpc.pb.go

// Package v1 is a generated GoMock package.
package v1

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockStoreClient is a mock of StoreClient interface.
type MockStoreClient struct {
	ctrl     *gomock.Controller
	recorder *MockStoreClientMockRecorder
}

// MockStoreClientMockRecorder is the mock recorder for MockStoreClient.
type MockStoreClientMockRecorder struct {
	mock *MockStoreClient
}

// NewMockStoreClient creates a new mock instance.
func NewMockStoreClient(ctrl *gomock.Controller) *MockStoreClient {
	mock := &MockStoreClient{ctrl: ctrl}
	mock.recorder = &MockStoreClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStoreClient) EXPECT() *MockStoreClientMockRecorder {
	return m.recorder
}

// BuyItem mocks base method.
func (m *MockStoreClient) BuyItem(ctx context.Context, in *BuyItemReq, opts ...grpc.CallOption) (*BuyItemResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BuyItem", varargs...)
	ret0, _ := ret[0].(*BuyItemResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuyItem indicates an expected call of BuyItem.
func (mr *MockStoreClientMockRecorder) BuyItem(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyItem", reflect.TypeOf((*MockStoreClient)(nil).BuyItem), varargs...)
}

// BuyPass mocks base method.
func (m *MockStoreClient) BuyPass(ctx context.Context, in *BuyPassReq, opts ...grpc.CallOption) (*BuyPassResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BuyPass", varargs...)
	ret0, _ := ret[0].(*BuyPassResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuyPass indicates an expected call of BuyPass.
func (mr *MockStoreClientMockRecorder) BuyPass(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyPass", reflect.TypeOf((*MockStoreClient)(nil).BuyPass), varargs...)
}

// BuyVIP mocks base method.
func (m *MockStoreClient) BuyVIP(ctx context.Context, in *BuyVIPReq, opts ...grpc.CallOption) (*BuyVIPResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BuyVIP", varargs...)
	ret0, _ := ret[0].(*BuyVIPResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuyVIP indicates an expected call of BuyVIP.
func (mr *MockStoreClientMockRecorder) BuyVIP(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyVIP", reflect.TypeOf((*MockStoreClient)(nil).BuyVIP), varargs...)
}

// HotSaleList mocks base method.
func (m *MockStoreClient) HotSaleList(ctx context.Context, in *HotSaleListReq, opts ...grpc.CallOption) (*HotSaleListResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HotSaleList", varargs...)
	ret0, _ := ret[0].(*HotSaleListResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HotSaleList indicates an expected call of HotSaleList.
func (mr *MockStoreClientMockRecorder) HotSaleList(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HotSaleList", reflect.TypeOf((*MockStoreClient)(nil).HotSaleList), varargs...)
}

// SaleList mocks base method.
func (m *MockStoreClient) SaleList(ctx context.Context, in *SaleListReq, opts ...grpc.CallOption) (*SaleListResp, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaleList", varargs...)
	ret0, _ := ret[0].(*SaleListResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaleList indicates an expected call of SaleList.
func (mr *MockStoreClientMockRecorder) SaleList(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaleList", reflect.TypeOf((*MockStoreClient)(nil).SaleList), varargs...)
}

// MockStoreServer is a mock of StoreServer interface.
type MockStoreServer struct {
	ctrl     *gomock.Controller
	recorder *MockStoreServerMockRecorder
}

// MockStoreServerMockRecorder is the mock recorder for MockStoreServer.
type MockStoreServerMockRecorder struct {
	mock *MockStoreServer
}

// NewMockStoreServer creates a new mock instance.
func NewMockStoreServer(ctrl *gomock.Controller) *MockStoreServer {
	mock := &MockStoreServer{ctrl: ctrl}
	mock.recorder = &MockStoreServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStoreServer) EXPECT() *MockStoreServerMockRecorder {
	return m.recorder
}

// BuyItem mocks base method.
func (m *MockStoreServer) BuyItem(arg0 context.Context, arg1 *BuyItemReq) (*BuyItemResp, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuyItem", arg0, arg1)
	ret0, _ := ret[0].(*BuyItemResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuyItem indicates an expected call of BuyItem.
func (mr *MockStoreServerMockRecorder) BuyItem(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyItem", reflect.TypeOf((*MockStoreServer)(nil).BuyItem), arg0, arg1)
}

// BuyPass mocks base method.
func (m *MockStoreServer) BuyPass(arg0 context.Context, arg1 *BuyPassReq) (*BuyPassResp, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuyPass", arg0, arg1)
	ret0, _ := ret[0].(*BuyPassResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuyPass indicates an expected call of BuyPass.
func (mr *MockStoreServerMockRecorder) BuyPass(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyPass", reflect.TypeOf((*MockStoreServer)(nil).BuyPass), arg0, arg1)
}

// BuyVIP mocks base method.
func (m *MockStoreServer) BuyVIP(arg0 context.Context, arg1 *BuyVIPReq) (*BuyVIPResp, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuyVIP", arg0, arg1)
	ret0, _ := ret[0].(*BuyVIPResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuyVIP indicates an expected call of BuyVIP.
func (mr *MockStoreServerMockRecorder) BuyVIP(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyVIP", reflect.TypeOf((*MockStoreServer)(nil).BuyVIP), arg0, arg1)
}

// HotSaleList mocks base method.
func (m *MockStoreServer) HotSaleList(arg0 context.Context, arg1 *HotSaleListReq) (*HotSaleListResp, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HotSaleList", arg0, arg1)
	ret0, _ := ret[0].(*HotSaleListResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HotSaleList indicates an expected call of HotSaleList.
func (mr *MockStoreServerMockRecorder) HotSaleList(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HotSaleList", reflect.TypeOf((*MockStoreServer)(nil).HotSaleList), arg0, arg1)
}

// SaleList mocks base method.
func (m *MockStoreServer) SaleList(arg0 context.Context, arg1 *SaleListReq) (*SaleListResp, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaleList", arg0, arg1)
	ret0, _ := ret[0].(*SaleListResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaleList indicates an expected call of SaleList.
func (mr *MockStoreServerMockRecorder) SaleList(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaleList", reflect.TypeOf((*MockStoreServer)(nil).SaleList), arg0, arg1)
}

// mustEmbedUnimplementedStoreServer mocks base method.
func (m *MockStoreServer) mustEmbedUnimplementedStoreServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedStoreServer")
}

// mustEmbedUnimplementedStoreServer indicates an expected call of mustEmbedUnimplementedStoreServer.
func (mr *MockStoreServerMockRecorder) mustEmbedUnimplementedStoreServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedStoreServer", reflect.TypeOf((*MockStoreServer)(nil).mustEmbedUnimplementedStoreServer))
}

// MockUnsafeStoreServer is a mock of UnsafeStoreServer interface.
type MockUnsafeStoreServer struct {
	ctrl     *gomock.Controller
	recorder *MockUnsafeStoreServerMockRecorder
}

// MockUnsafeStoreServerMockRecorder is the mock recorder for MockUnsafeStoreServer.
type MockUnsafeStoreServerMockRecorder struct {
	mock *MockUnsafeStoreServer
}

// NewMockUnsafeStoreServer creates a new mock instance.
func NewMockUnsafeStoreServer(ctrl *gomock.Controller) *MockUnsafeStoreServer {
	mock := &MockUnsafeStoreServer{ctrl: ctrl}
	mock.recorder = &MockUnsafeStoreServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeStoreServer) EXPECT() *MockUnsafeStoreServerMockRecorder {
	return m.recorder
}

// mustEmbedUnimplementedStoreServer mocks base method.
func (m *MockUnsafeStoreServer) mustEmbedUnimplementedStoreServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedStoreServer")
}

// mustEmbedUnimplementedStoreServer indicates an expected call of mustEmbedUnimplementedStoreServer.
func (mr *MockUnsafeStoreServerMockRecorder) mustEmbedUnimplementedStoreServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedStoreServer", reflect.TypeOf((*MockUnsafeStoreServer)(nil).mustEmbedUnimplementedStoreServer))
}
